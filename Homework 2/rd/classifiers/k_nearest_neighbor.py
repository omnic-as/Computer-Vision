from builtins import range
from builtins import object
import numpy as np


class KNearestNeighbor(object):
    """ k ближайших соседей с L2 мерой """

    def __init__(self):
        pass

    def train(self, X, y):
        """
        - X: массив тренировочных данных размера (num_train, D)
        - y: массив меток размера (N,), где y[i] - метка X[i].
        """
        self.X_train = X
        self.y_train = y

    def predict(self, X, k=1, num_loops=0):
        """
        Аргументы:
        - X: массив тестовых данных
        - k: количество ближайших соседей
        - num_loops: определяет какой из методов для вычисления расстояний использовать

        Возвращает:
        - y: массив предсказанных меток для тестовых данных
        """
        if num_loops == 0:
            dists = self.compute_distances_no_loops(X)
        elif num_loops == 1:
            dists = self.compute_distances_one_loop(X)
        elif num_loops == 2:
            dists = self.compute_distances_two_loops(X)
        else:
            raise ValueError('Invalid value %d for num_loops' % num_loops)

        return self.predict_labels(dists, k=k)

    def compute_distances_two_loops(self, X):
        """
        Вычислить расстояние между каждой контрольной точкой в X и каждой тренировочной точкой
         в self.X_train с использованием вложенного цикла как для обучающих данных, так и для
         тестовых данных.

        Аргументы:
        - X: массив тестовых данных

        Возвращает:
        - dists: Массив размера (num_test, num_train), где dists[i, j] -  евклидово
         расстояние между i-й тестовой точкой и j-й тренировкой точкой.
        """
        num_test = X.shape[0]
        num_train = self.X_train.shape[0]
        dists = np.zeros((num_test, num_train))
        for i in range(num_test):
            for j in range(num_train):
                ##############################################################
                # TODO:                                                      #
                # Вычислить l2 расстояние между i-й тест точкой и j-й        #
                # тренировочной точкой, записать результат в dists[i, j].    #
                # не используя циклы по размерностям, вкл. np.linalg.norm(). #
                ##############################################################
                # *****НАЧАЛО ВАШЕГО КОДА (НЕ УДАЛЯЙТЕ / ИЗМЕНЯЙТЕ ЭТУ СТРОКУ)*****

                pass

                # *****КОНЕЦ ВАШЕГО КОДА (НЕ УДАЛЯЙТЕ / ИЗМЕНЯЙТЕ ЭТУ СТРОКУ)*****
        return dists

    def compute_distances_one_loop(self, X):
        """
        Вычислить расстояние между каждой тестовой точкой в X и каждой тренировочной точкой
         в self.X_train, используя один цикл над тестовыми данными.
        """
        num_test = X.shape[0]
        num_train = self.X_train.shape[0]
        dists = np.zeros((num_test, num_train))
        for i in range(num_test):
            ########################################################################
            # TODO:                                                                #
            # Вычислить l2 расстояние между i-й тест точкой и всеми тренировочными #
            # точками, записать результат в dists[i, :].                           #
            # Не используйте np.linalg.norm().                                     #
            ########################################################################
            # *****НАЧАЛО ВАШЕГО КОДА (НЕ УДАЛЯЙТЕ / ИЗМЕНЯЙТЕ ЭТУ СТРОКУ)*****

            pass

            # *****КОНЕЦ ВАШЕГО КОДА (НЕ УДАЛЯЙТЕ / ИЗМЕНЯЙТЕ ЭТУ СТРОКУ)*****
        return dists

    def compute_distances_no_loops(self, X):
        """
        Вычислить расстояние между каждой тестовой точкой в X и каждой тренировочной точкой
         в self.X_train, не используя цикл(ы).
        """
        num_test = X.shape[0]
        num_train = self.X_train.shape[0]
        dists = np.zeros((num_test, num_train))
        #########################################################################
        # TODO:                                                                 #
        # Вычислить расстояние l2 между всеми тест точками и тренировочными     #
        # точками без использования явных циклов, и сохраните результат в dists #
        #                                                                       #
        # Вы должны использовать только базовые операции с массивами;           #
        # не используя методов из scipy и np.linalg.norm().                     #
        #########################################################################
        # *****НАЧАЛО ВАШЕГО КОДА (НЕ УДАЛЯЙТЕ / ИЗМЕНЯЙТЕ ЭТУ СТРОКУ)*****

        pass

        # *****КОНЕЦ ВАШЕГО КОДА (НЕ УДАЛЯЙТЕ / ИЗМЕНЯЙТЕ ЭТУ СТРОКУ)*****
        return dists

    def predict_labels(self, dists, k=1):
        """
        Аргументы:
        - dists: массив расстояний размера (num_test, num_train)

        Возвращает:
        - y: массив предсказанных меток
        """
        num_test = dists.shape[0]
        y_pred = np.zeros(num_test)
        for i in range(num_test):
            # массив с метками k ближайших соседей i-й тест точки
            closest_y = []
            #########################################################################
            # TODO:                                                                 #
            # Используйте матрицу расстояний, чтобы найти k ближайших соседей,      #
            # используйте self.y_train, чтобы получить метки соседей.               #
            # Сохраните метки в closest_y.                                          #
            #########################################################################
            # *****НАЧАЛО ВАШЕГО КОДА (НЕ УДАЛЯЙТЕ / ИЗМЕНЯЙТЕ ЭТУ СТРОКУ)*****

            pass

            # *****КОНЕЦ ВАШЕГО КОДА (НЕ УДАЛЯЙТЕ / ИЗМЕНЯЙТЕ ЭТУ СТРОКУ)*****
            #########################################################################
            # TODO:                                                                 #
            # Определите самую распространенную метку в list closest_y,             #
            # запишите ее в y_pred[i].                                              #
            #########################################################################
            # *****НАЧАЛО ВАШЕГО КОДА (НЕ УДАЛЯЙТЕ / ИЗМЕНЯЙТЕ ЭТУ СТРОКУ)*****

            pass

            # *****КОНЕЦ ВАШЕГО КОДА (НЕ УДАЛЯЙТЕ / ИЗМЕНЯЙТЕ ЭТУ СТРОКУ)*****

        return y_pred
